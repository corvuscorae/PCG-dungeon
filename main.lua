-- Procedural Dungeon Generator (BSP)
-- For CMPM 170-03
-- Raven Cruz and Shazer Rizzo

--[[ TODO:
    > write logic for splitting paragraphs when there are too few to fill every room
    > write a Story class that can identify objectives from each story paragraph and
        determine whther objectives are filled.
]]
require("descriptionGenerator");
require("story_handler");

local Entity = require("entity")
local Wall = require("wall")
local Story = require('text');
local story_copy = deepCopy(Story); -- so we can maintain a clean version for reload
local walls = {};

local visit_history = {}
local active_objectives = {
    index = {},
    obj = {}
}
local resolved_objectives = {
    index = {},
    obj = {}
}

function love.load()
    math.randomseed(os.time())

    -- Window settings
    love.window.setTitle("Dungeon Crawler")
    love.window.setMode(1000, 800) -- wider for split panel

    -- Panel sizes
    MAP_WIDTH = 600
    INFO_WIDTH = 400
    WINDOW_HEIGHT = 800 -- Store for convenience
    TEXT_PADDING = 40

    -- Colors
    colors = {
        background = {0.1, 0.1, 0.1},
        wall = {0.3, 0.3, 0.3},
        floor = {0.5, 0.5, 0.5}, -- Floor and Corridor use the same color now
        grid_line = {0.2, 0.2, 0.2, 0.5}, -- Dim grid lines
        player = {1, 1, 0}, -- yellow
        text = {
            dark = {0.3, 0.3, 0.3},
            light = {1, 1, 1}
        }
    }

    -- Dungeon settings
    GRID_DIM = 32 
    CELL_SIZE = MAP_WIDTH / GRID_DIM 
    MIN_LEAF_SIZE = 4
    MAX_DEPTH = 4
    ROOM_PADDING = 1
    MIN_ROOM_SIZE = 2

    font = love.graphics.newFont(14)
    love.graphics.setFont(font)

    local dungeon = generateDungeon()
    placePlayerInStartingRoom()

    storyToRooms(dungeon);

end

function generateDungeon()
    dungeon = {
        rooms = {},
        grid = {}  -- grid[y][x] -> 1 for wall, 0 for floor
    }

    -- 1. Initialize grid with all walls
    for y = 1, GRID_DIM do
        dungeon.grid[y] = {}
        for x = 1, GRID_DIM do
            dungeon.grid[y][x] = 1
        end
    end

    local rootNode = {
        x = 1, y = 1, 
        width = GRID_DIM, 
        height = GRID_DIM, 
        children = {}, 
        room = nil,
    }
    local leaves = {}
    splitSpace(rootNode, 0, leaves)
    createRoomsInLeaves(leaves)
    connectRooms(rootNode)

    -- make wall entities
    for y = 1, GRID_DIM do
        for x = 1, GRID_DIM do
            local screenX = (x - 1) * CELL_SIZE
            local screenY = (y - 1) * CELL_SIZE
            if dungeon.grid[y][x] == 1 then
                -- place wall
                local wall = Wall:new(
                    x * CELL_SIZE - CELL_SIZE, 
                    y * CELL_SIZE - CELL_SIZE, 
                    CELL_SIZE, CELL_SIZE)
                table.insert(walls, wall);
            end
        end
    end

    return dungeon
end

-- Recursively split space using BSP
function splitSpace(node, depth, leaves)
    -- Stop splitting if max depth reached or node is too small
    if depth >= MAX_DEPTH or (node.width <= MIN_LEAF_SIZE * 2 and node.height <= MIN_LEAF_SIZE * 2) then
        table.insert(leaves, node)
        return true
    end
    
     -- Decide split direction (prefer splitting the longer dimension)
    local splitHorizontally = node.width > node.height and node.width > MIN_LEAF_SIZE * 2
    local splitVertically = node.height >= node.width and node.height > MIN_LEAF_SIZE * 2

     -- If can't split further in preferred direction, try the other
    if not splitHorizontally and not splitVertically then
        table.insert(leaves, node)
        return true
    end

    local splitDirection
    if splitHorizontally and splitVertically then
        splitDirection = math.random() > 0.5 and "horizontal" or "vertical"
    elseif splitHorizontally then
        splitDirection = "horizontal"
    else
        splitDirection = "vertical"
    end

    -- Perform the split
    local splitPoint
    if splitDirection == "horizontal" then
        -- Ensure split leaves enough room on both sides
        splitPoint = math.random(MIN_LEAF_SIZE, node.width - MIN_LEAF_SIZE)
        node.children[1] = {x = node.x, y = node.y, width = splitPoint, height = node.height, children = {}, room = nil}
        node.children[2] = {x = node.x + splitPoint, y = node.y, width = node.width - splitPoint, height = node.height, children = {}, room = nil}
    else
        splitPoint = math.random(MIN_LEAF_SIZE, node.height - MIN_LEAF_SIZE)
        node.children[1] = {x = node.x, y = node.y, width = node.width, height = splitPoint, children = {}, room = nil}
        node.children[2] = {x = node.x, y = node.y + splitPoint, width = node.width, height = node.height - splitPoint, children = {}, room = nil}
    end

    splitSpace(node.children[1], depth + 1, leaves)
    splitSpace(node.children[2], depth + 1, leaves)
end

-- Create rooms within the leaf nodes generated by splitSpace
function createRoomsInLeaves(leaves)
    i = 0   -- Track room index
    for _, leaf in ipairs(leaves) do
        -- Calculate potential room size (smaller than leaf, respecting padding)
        local potentialW = leaf.width - ROOM_PADDING * 2
        local potentialH = leaf.height - ROOM_PADDING * 2

        if potentialW >= MIN_ROOM_SIZE and potentialH >= MIN_ROOM_SIZE then
            i = i + 1
             -- Randomize size slightly, ensure minimum size
            local roomW = math.random(MIN_ROOM_SIZE, potentialW)
            local roomH = math.random(MIN_ROOM_SIZE, potentialH)
            -- Randomize position within the available padded space
            local roomX = leaf.x + ROOM_PADDING + math.random(0, potentialW - roomW)
            local roomY = leaf.y + ROOM_PADDING + math.random(0, potentialH - roomH)

            -- Create room object
            leaf.room = {
                x = roomX, y = roomY, width = roomW, height = roomH,
                center = { x = roomX + math.floor(roomW / 2), y = roomY + math.floor(roomH / 2) },
                description = generateRoomDescription(roomW, roomH),
                index = i,
                paragraph = ""
            }

            -- Carve room into the grid
            table.insert(dungeon.rooms, leaf.room)
            carveRect(roomX, roomY, roomW, roomH, 0)
        end
    end
end

-- Connect rooms associated with sibling nodes in the BSP tree
function connectRooms(node)
    if #node.children ~= 2 then return end
    -- Recursively connect children first
    connectRooms(node.children[1])
    connectRooms(node.children[2])
    -- Find a room in each child subtree (can be nil if a branch didn't produce rooms)
    local room1 = getRandomRoomFromNode(node.children[1])
    local room2 = getRandomRoomFromNode(node.children[2])

    -- If both subtrees have rooms, connect them
    if room1 and room2 then
        createCorridor(room1.center.x, room1.center.y, room2.center.x, room2.center.y)
    end
end

-- Helper: Get a random room from a node or its descendants
function getRandomRoomFromNode(node)
    if node.room then return node.room end
    local rooms = {}
    local function find(node)
        if node.room then table.insert(rooms, node.room)
        else for _, c in ipairs(node.children) do find(c) end end
    end
    find(node)
    return #rooms > 0 and rooms[math.random(#rooms)] or nil
end

function carveRect(x, y, w, h, tile)
    for j = y, y + h - 1 do
        for i = x, x + w - 1 do
            if j >= 1 and j <= GRID_DIM and i >= 1 and i <= GRID_DIM then
                dungeon.grid[j][i] = tile
            end
        end
    end
end

-- Create an L-shaped corridor between two points by carving the grid
function createCorridor(x1, y1, x2, y2)
    if math.random() > 0.5 then
        carveRect(math.min(x1, x2), y1, math.abs(x1 - x2) + 1, 1, 0)
        carveRect(x2, math.min(y1, y2), 1, math.abs(y1 - y2) + 1, 0)
    else
        carveRect(x1, math.min(y1, y2), 1, math.abs(y1 - y2) + 1, 0)
        carveRect(math.min(x1, x2), y2, math.abs(x1 - x2) + 1, 1, 0)
    end
end

-- SHAZER: Made Player instance in game, which can be controlled
function placePlayerInStartingRoom()
    local largest = dungeon.rooms[1]
    for _, room in ipairs(dungeon.rooms) do
        if (room.width * room.height) > (largest.width * largest.height) then
            largest = room
        end
    end
    player = {
        x = largest.center.x,
        y = largest.center.y,
        room = largest
    }
end

-- SHAZER: Movement for player
--function love.update(dt)
--  local dx, dy = 0, 0
    --if love.keyboard.isDown("w") then dy = -1 end
    --if love.keyboard.isDown("s") then dy =  1 end
    --if love.keyboard.isDown("a") then dx = -1 end
    --if love.keyboard.isDown("d") then dx =  1 end

function movePlayer(dx, dy)
    local newX = player.x + dx
    local newY = player.y + dy

    if dungeon.grid[newY] and dungeon.grid[newY][newX] == 0 then
        player.x = newX
        player.y = newY
        updatePlayerRoom()
    end
end

--end
function updatePlayerRoom()
    for _, room in ipairs(dungeon.rooms) do
        if player.x >= room.x and player.x < room.x + room.width and
           player.y >= room.y and player.y < room.y + room.height then
            player.room = room

            -- add room paragraph(s) to visit_history
            for i,p in pairs(room.paragraph.index) do 
                if arrayHas(visit_history, p) == false then
                    table.insert(visit_history, p);

                    -- check to see if any of the active objective can be solved
                    if #active_objectives.obj > 0 then
                        resolveObjective(room.paragraph, active_objectives, resolved_objectives);
                    end

                    -- get new objectives from new room 
                    getObjectives(room.paragraph, visit_history, active_objectives, resolved_objectives);
                end
            end
            
            return
        end
    end
    player.room = nil -- in corridor
end

function love.draw()
    -- Draw dungeon map
    for y = 1, GRID_DIM do
        for x = 1, GRID_DIM do
            local screenX = (x - 1) * CELL_SIZE
            local screenY = (y - 1) * CELL_SIZE
            if dungeon.grid[y][x] ~= 1 then
                -- draw ground tile
                love.graphics.setColor(colors.floor)
            end
            love.graphics.rectangle("fill", screenX, screenY, CELL_SIZE, CELL_SIZE)
            love.graphics.setColor(colors.grid_line)
            love.graphics.rectangle("line", screenX, screenY, CELL_SIZE, CELL_SIZE)
        end
    end

    -- DEBUG: print room index
    --for _, room in ipairs(dungeon.rooms) do
    --    love.graphics.setColor(1, 0, 0, 1)
    --    love.graphics.print(room.index, room.x * CELL_SIZE, room.y * CELL_SIZE)
    --end 

    -- Draw player
    love.graphics.setColor(colors.player)
    love.graphics.circle("fill", (player.x - 0.5) * CELL_SIZE, (player.y - 0.5) * CELL_SIZE, CELL_SIZE / 3)

    -- Right panel - Room info
    love.graphics.setColor(colors.text.dark)
    local baseX = MAP_WIDTH + 20
    love.graphics.print("Dungeon Status", baseX, 20)
    if player.room then
        --DEBUGL print room paragraph indeces
        --local ind_str = ""
        --for i,ind in pairs(player.room.paragraph.index) do
        --    ind_str = ind_str .. tostring(ind) .. " "
        --end
        --love.graphics.printf("Room: " .. ind_str .. "\n" .. 
        --    player.room.description .. "\n", baseX, 60, INFO_WIDTH - TEXT_PADDING);

        love.graphics.printf("Room: " .. player.room.description .. "\n", baseX, 60, INFO_WIDTH - TEXT_PADDING);

        love.graphics.setColor(colors.text.light)
        love.graphics.printf( "\n" .. player.room.paragraph.text .. "\n", baseX, 120, INFO_WIDTH - TEXT_PADDING);
        
    else
        love.graphics.setColor(colors.text.dark)
        love.graphics.print("You are in a dark corridor.", baseX, 60)
    end

    -- Bottom panel: objective info
    love.graphics.setColor(colors.text.light)
    local active_obj_str = objectiveString(active_objectives.obj);
    love.graphics.printf("ACTIVE OBJECTIVES: " .. active_obj_str,
        TEXT_PADDING, (GRID_DIM * CELL_SIZE) + TEXT_PADDING, (GRID_DIM * CELL_SIZE) - TEXT_PADDING);

    -- Regenerate instruction
    love.graphics.setColor(colors.text.dark)
    love.graphics.print("Press 'R' to regenerate.", baseX, WINDOW_HEIGHT - TEXT_PADDING)

    --love.graphics.print(tostring(active_objectives[#active_objectives].text), baseX, WINDOW_HEIGHT - TEXT_PADDING*2)

    -- draw walls
    for _, wall in ipairs(walls) do
        wall:draw()
    end
    
end

function objectiveString(objs)
    local str = ""
    for i,obj in pairs(objs) do
        str = str .. obj.text .. " "
    end
    return str;
end

function love.keypressed(key) 
    -- RAVEN: grid-based movement controls instead of smooth movement
    local dx, dy = 0, 0

    local move = false;
    if     key == "w" then dy = -1 move=true 
    elseif key == "a" then dx = -1 move=true 
    elseif key == "s" then dy =  1 move=true 
    elseif key == "d" then dx =  1 move=true 
    end

    if move == true then movePlayer(dx, dy) end

    if key == "r" then
        print("-----------------------------------");   -- for console readability
        walls = {}
        local dungeon = generateDungeon()
        placePlayerInStartingRoom()
        story_copy = {}
        story_copy = deepCopy(Story); -- proceed with clean copy of story
        storyToRooms(dungeon)
        visit_history = {}

        -- clear objective history
        active_objectives = {
            index = {},
            obj = {}
        }
        resolved_objectives = {
            index = {},
            obj = {}
        }
    end
    if key == "escape" then
        love.event.quit()
    end
end

 -- RAVEN: assign paragraphs of story to dungeon rooms
 function storyToRooms(dungeon)
    -- now that dungeon is generated, make sure #paragraphs matches #rooms
    --story = getParagraphs(story);

    -- make sure number of paragraphs matches number of rooms
    if #dungeon.rooms < #story_copy then
        combineShortest(#story_copy - #dungeon.rooms, story_copy, 
            {active = active_objectives, resolved = resolved_objectives});
    end

    --[[ 
    -- TODO: write logic for splitting paragraphs when there are too few to fill every room
    if #dungeon.rooms > #paragraphs then
        --print(#paragraphs, "...", #dungeon.rooms)
        --combineShortest(#paragraphs - #dungeon.rooms);
        --print(#paragraphs, "...", #dungeon.rooms)
    end
    ]]

    for i,room in ipairs(dungeon.rooms) do
        room.paragraph = story_copy[i]
        --print("\n" .. room.paragraph)
        --print("\n--")
    end

end